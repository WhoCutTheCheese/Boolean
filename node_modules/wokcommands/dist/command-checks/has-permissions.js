"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
let hasPerm
const Config = require("../../../../models/config")
const CommandErrors_1 = __importDefault(require("../enums/CommandErrors"));
module.exports = async (guild, command, instance, member, user, reply) => {
    if (!guild || !member) {
        return true;
    }
    const configuration = await Config.findOne({
        guildID: guild.id
    })
    const { requiredPermissions, error } = command;
    for (const perm of requiredPermissions || []) {
        // @ts-ignore
        if (!member.permissions.has(perm)) {
            hasPerm = false
        }
    }
    let requiredRoles
    if(hasPerm == false) {
        if(command.category === "Moderation") {
            if (configuration.modRoleID.length != 0) {
                requiredRoles = configuration.modRoleID
            } else {
                reply(instance.messageHandler.get(guild, 'MISSING_PERMISSION', {
                    PERM: "MANAGE_MESSAGES",
                })).then((message) => {
                    if (!message) {
                        return;
                    }
                    if (instance.delErrMsgCooldown === -1 || !message.deletable) {
                        return;
                    }
                    setTimeout(() => {
                        message.delete();
                    }, 1000 * instance.delErrMsgCooldown);
                });
                return false;
            } 
        } else if(command.category === "Configuration") {
            if (configuration.adminRoleID.length != 0) {
                requiredRoles = configuration.modRoleID
            } else {
                reply(instance.messageHandler.get(guild, 'MISSING_PERMISSION', {
                    PERM: "MANAGE_GUILD",
                })).then((message) => {
                    if (!message) {
                        return;
                    }
                    if (instance.delErrMsgCooldown === -1 || !message.deletable) {
                        return;
                    }
                    setTimeout(() => {
                        message.delete();
                    }, 1000 * instance.delErrMsgCooldown);
                });
                return false;
            } 
        } else if(command.category === "Administration") {
            if (configuration.adminRoleID.length != 0) {
                requiredRoles = configuration.modRoleID
            } else {
                reply(instance.messageHandler.get(guild, 'MISSING_PERMISSION', {
                    PERM: "ADMINISTRATOR",
                })).then((message) => {
                    if (!message) {
                        return;
                    }
                    if (instance.delErrMsgCooldown === -1 || !message.deletable) {
                        return;
                    }
                    setTimeout(() => {
                        message.delete();
                    }, 1000 * instance.delErrMsgCooldown);
                });
                return false;
            } 
        }
        let hasRoles
        for (const requiredRole of requiredRoles) {
            const role = guild?.roles.cache.get(requiredRole);
            if (!member?.roles.cache.has(requiredRole)) {
               hasRoles = false
            } else {
                hasRoles = true
                break;
            }
        }
        if(hasRoles == false) {
            reply(instance.messageHandler.get(guild, 'MISSING_PERMISSION', {
                PERM: "MOD_ROLE",
            })).then((message) => {
                if (!message) {
                    return;
                }
                if (instance.delErrMsgCooldown === -1 || !message.deletable) {
                    return;
                }
                setTimeout(() => {
                    message.delete();
                }, 1000 * instance.delErrMsgCooldown);
            });
            return false;
        }
    }
    return true;
};
